@page "/statblocks"
@rendermode InteractiveServer
@inject IJSRuntime JS
@inject DMTools.Database.DmtoolsContext dmToolsContext

<PageTitle>Stat Blocks</PageTitle>

<link rel="stylesheet" href="stat_block.css"/>
<script src="/lib/jquery/jquery.js"></script>
<script defer src="js/slideToggle.js"></script>
<div class="monster-upload-row">
    <label for="dminput" class="dmbutton dminput">
        Upload monster
    </label>
    <InputFile class="dmbutton" id="dminput" OnChange="@LoadFiles" />
    <input type="text" class="" @bind-value="SearchText" @bind-value:event="oninput" placeholder="Search by name" />
    <div class="search-monsters">
        <div class="selected-group">

        </div>
        <div class="available-monsters">
            <input type="text" placeholder="Search for a previously saved monster" />
            <div class="checkbox-mons">
                @foreach ((int id, string name) in this.monsterIds)
                {
                    <input id="@id" type="checkbox" value="@id" />
                    <label for="@id">@name</label>
                }
            </div>
        </div>
    </div>
</div>

<div class="row">
    @{
        int counter = 0;
    }
    @foreach (Monster monster in monsters.Where(mon => mon.Name.ToLower().Contains(SearchText.ToLower())))
    {
        monster.MonsterId = counter;
        <StatBlock monster="monster" OnDeleteButtonClicked="DeleteMonster" ></StatBlock>
        counter++;
        //RegisterSlide(counter);
    }
</div>


<footer class="page-footer">
    This site directly uses the files downloaded from <a href="https://tetra-cube.com/dnd/dnd-statblock.html">this stat block generator</a>. 
    Please note that this person rounds <i>down</i> when doing dice calculations, and I round <i>up</i>, which is why you may see some differences.
</footer>

@code {
    List<DMTools.Database.Entities.StatBlock> monsters = new List<DMTools.Database.Entities.StatBlock>();

    public string SearchText { get; set; } = "";

    public List<(int, string)> monsterIds { get; set; } = new();

    StatBlockFactory statBlockFactory = new StatBlockFactory();

    [CascadingParameter]
    private Task<AuthenticationState>? authenticationState { get; set; }
    private List<(int, string)> selectedMonsterIds { get; set; } = new List<(int, string)>();
    private List<IBrowserFile> loadedFiles = new();
    private long maxFileSize = 1024 * 15;
    private int maxAllowedFiles = 3;
    private bool isLoading;
    private int monsterId;

    protected override async Task OnParametersSetAsync()
    {
        if (authenticationState is not null)
        {
            var auth = await authenticationState;

            if (auth.User.Identity.IsAuthenticated)
            {
                string id = (auth.User.Claims.FirstOrDefault(cl => cl.Type == ClaimTypes.NameIdentifier)).Value;
                var mons = this.dmToolsContext.Monster
                   .Where(mon =>
                       mon.UserGuid ==
                           id)
                   .Select(mon => new { mon.MonsterId, mon.Name }).ToList();
                foreach (var result in mons)
                {
                    this.monsterIds.Add((result.MonsterId, result.Name));
                }
            }
        }

        await base.OnParametersSetAsync();
        return;
    }

    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        this.isLoading = true;

        foreach (IBrowserFile file in e.GetMultipleFiles())
        {
            try
            {
                loadedFiles.Add(file);
                // technically NOT recommended, but these JSON files are ~4 KB in size, so it
                // *really* shouldn't matter that much...
                // https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0
                var reader =
                    await new StreamReader(file.OpenReadStream()).ReadToEndAsync();

                DMTools.Database.Entities.StatBlock statBlock = this.statBlockFactory.CreateStatBlock("Monster", reader);

                // did statBlock actually get created?
                if (statBlock is null)
                {
                    throw new ArgumentException("Statblock could not be created.");
                }

                UploadedBlocks(statBlock);
            }
            catch (Exception)
            {
                // do somethiing
            }
        }
        this.isLoading = false;
    }

    public void UploadedBlocks(DMTools.Database.Entities.StatBlock monster)
    {
        monsters.Add(monster);
    }

    public async Task RegisterSlide(int counter)
    {
        await JS.InvokeVoidAsync("RegisterSlide", new object[] { 1 });
    }

    public async Task DeleteMonster(object monster)
    {
        this.monsters.Remove(monster as Monster);
    }

    public void AddCheckBox(MouseEventArgs e)
    {
        var list = 0;
    }
}
